<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shengdoupi&#39;s</title>
  
  <subtitle>posts</subtitle>
  <link href="http://shengdoupi.github.io/atom.xml" rel="self"/>
  
  <link href="http://shengdoupi.github.io/"/>
  <updated>2023-12-10T12:37:10.952Z</updated>
  <id>http://shengdoupi.github.io/</id>
  
  <author>
    <name>shengdoupi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://shengdoupi.github.io/2023/11/25/test/"/>
    <id>http://shengdoupi.github.io/2023/11/25/test/</id>
    <published>2023-11-25T11:04:11.946Z</published>
    <updated>2023-12-10T12:37:10.952Z</updated>
    
    <content type="html"><![CDATA[<p>概览<br>最近优化业务日志规范，我们定义了日志打点的数据结构是形如key-value结构，其中key是日志的业务语意，value为对应的业务值，每处打点我们希望可以实现多个业务语意-值的映射对，并在日志中按照我们在代码中的顺序输出出来。即我们需要一个有序映射的数据结构来做存储，选择使用LinkedHashMap。<br>Java集合中有些接口或实现类是约束、实现了元素有序能力的，这里分两类：</p><ol><li>键自然序或者指定比较顺序进行键值排序的能力，比如SortedMap（对应的SortedSet），其实现类TreeMap；</li><li>按元素的插入先后顺序进行排序，比如接口List、Queue，以及Map的实现类LinkedHashMap这些；<br>这篇文章专门介绍Java中有序集合的实现，特别地从源码介绍TreeMap和LinkedHashmap。<br>TreeMap</li></ol><p>按照类继承关系，下面先介绍Map、SortedMap和NavigableMap的接口规范和方法约束，然后详细介绍TreeMap的方法实现。<br>Map<br>Map是一个将键映射到值的对象。映射不能包含重复的键；每个键最多可以映射到一个值。<br>Map接口提供了三个集合视图，允许将Map的内容视为一组键、一组值或一组键值映射。Map的顺序定义为其集合视图上的迭代器返回其元素的顺序。一些Map实现，如TreeMap类，对它们的顺序做出了特定的保证；其他类（如HashMap类）则不然。<br>上述截取自JDK官方对Map接口的注解翻译，Map主要是用来存放不重复的键以及其键-值唯一映射。Map接口规范没有约束按特定顺序存放元素和按序读取元素的能力。<br>SortedMap<br>SortedMap是一个进一步提供其键的总排序的Map。SortedMap是根据其键的自然顺序进行排序的，或者由通常在SortedMap创建时提供的比较器进行排序。当迭代SortedMap的集合视图（由entrySet、keySet和values方法返回）时，会反映出这种顺序。提供了几个额外的操作以利用有序能力。<br>上述截取自SortedMap的官方注释，SortedMap提供了键的排序能力，以及一些方法来使用这个能力。下面先介绍接口规范再介绍提供的方法。<br>接口规范</p><ol><li>插入排序映射的所有键都必须实现Comparable接口（或被指定的comparator接受）。此外，所有这些键必须是相互可比较的：k1.compareTo（k2）（或comparator.compare（k1，k2））。<br>第一点是SortedMap有序能力本质上需要依赖compareTo方法或者compare方法，因此键的类型必须实现Comparable接口或者被某个comparator接受。</li><li>如果SortedMap要正确实现map接口，则SortedMap（无论是否提供显式比较器）维护的顺序必须与equals一致。这是因为Map接口是根据equals操作定义的，但SortedMap使用compareTo（或compare）方法执行键之间的比较，因此从SortedMap的角度来看，compareTo认为相等的两个键需要是equal的。（TreeMap行为是明确定义的，即使它的排序与等于不一致；它只是没有遵守Map接口的一般约定。）<br>第二点是说SortedMap比较键值时使用的compareTo或compare方法需要与equals结果一致；这点Comparator接口里有更具体的规范：<br>(compare(x, y)&#x3D;&#x3D;0) &#x3D;&#x3D; (x.equals(y))<br>这处约束主要是Map接口约束使用equals方法来判定键是否相同，SortedMap接口约束使用compare方法来比较两个键的顺序，而SortedMap是Map接口的扩展接口，因此需要遵循Map接口的约束，也即判断键是否相同这点两处需要保持一致；</li><li>所有通用SortedMap实现类都应该提供四个“标准”构造函数。虽然接口不能指定必需的构造函数，但不可能强制执行此建议。所有SortedMap现的预期“标准”构造函数是：<br>1)一个void（无参数）构造函数，它创建一个根据键的自然顺序排序的空SortedMap。<br>2)具有Comparator类型的单个参数的构造函数，它创建一个根据指定的比较器排序的空SortedMap。<br>3)具有Map类型的单个参数的构造函数，它创建一个新的映射，该映射具有与其参数相同的键值映射，并根据键的自然顺序进行排序。<br>4)具有SortedMap类型的单个参数的构造函数，它创建一个新的SortedMap，其具有与输入SortedMap相同的键值映射和顺序。<br>第三点约束是SortedMap接口对构造函数的要求，总结就是当参数里不指定特定的比较方法时，构造的对象需提供自然顺序排序的能力。<br>方法<br>SortedMap提供了一些方法利用到排序能力：<br>&#x2F;&#x2F; 指定键起止范围的子映射<br>SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);<br>&#x2F;&#x2F; 从第一个键到指定键的子映射<br>SortedMap&lt;K,V&gt; headMap(K toKey);<br>&#x2F;&#x2F; 从指定键到最后一个键的子映射<br>SortedMap&lt;K,V&gt; tailMap(K fromKey);<br>&#x2F;&#x2F; 返回当前第一个键<br>K firstKey();<br>&#x2F;&#x2F; 返回当前最后一个键<br>K lastKey();<br>NavigableMap<br>SortedMap提供的方法中对有序的利用能力局限在获取已知键大小范围对应的映射，而很多时候我们并不知道需要获取的键的具体大小， 只知道一个方向：比如我们想获得比指定key大的下一个元素；这时只用SortedMap定义的方法我们只能获取到最大的key，然后再使用subMap获取指定key和最大key之间的子映射，再遍历获得比指定key大的下一个元素。<br>NavigableMap是SortedMap的扩展接口，顾名思义提供了导航的能力，提供了获取指定方向的键值对的方法，返回给定搜索目标的最接近匹配项。<br>接口规范<br>使用导航方法扩展的SortedMap，返回给定搜索目标的最接近匹配项。方法lowerEntry、floorEntry、ceilingEntry和higherEntry返回Map。分别与小于、小于或等于、大于或等于和大于给定键的键关联的条目对象，如果没有这样的键，则返回null。类似地，lowerKey、floorKey、ceilingKey和higherKey方法只返回关联的键。所有这些方法都是为定位而设计的，而不是遍历条目。<br>方法<br>NavigableMap新增的方法除了接口规范中已提及的还有：<br>&#x2F;&#x2F; 返回对应的逆序集合<br>NavigableMap&lt;K,V&gt; descendingMap();<br>&#x2F;&#x2F; 移除此时第一个元素并返回<br>Map.Entry&lt;K,V&gt; pollFirstEntry();<br>&#x2F;&#x2F; 移除此时最后一个元素并返回<br>Map.Entry&lt;K,V&gt; pollLastEntry();<br>TreeMap源码<br>一句话，TreeMap的有序能力基于红黑树（<a href="https://oi-wiki.org/ds/rbtree/%EF%BC%89%E5%AE%9E%E7%8E%B0%E3%80%82%E5%9B%A0%E6%AD%A4TreeMap%E7%9A%84%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(log(n)">https://oi-wiki.org/ds/rbtree/）实现。因此TreeMap的元素插入、查找和删除的时间复杂度为O(log(n)</a>), 其中n为元素的个数。<br>属性<br>Entry类<br> static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br> K key;<br> V value;<br> Entry&lt;K,V&gt; left;<br> Entry&lt;K,V&gt; right;<br> Entry&lt;K,V&gt; parent;<br> boolean color &#x3D; BLACK;<br><br> &#x2F;**<br>  * Make a new cell with given key, value, and parent, and with<br>  * {@code null} child links, and BLACK color.<br>  *&#x2F;<br> Entry(K key, V value, Entry&lt;K,V&gt; parent) {<br>     this.key &#x3D; key;<br>     this.value &#x3D; value;<br>     this.parent &#x3D; parent;<br> }<br><br> …<br> }</li></ol><p>TreeMap的Entry类作为元素类，除了基本的key、value之外，自身还作为一个节点包括了红黑树的节点信息：父节点、左右子节点和颜色布尔值。<br>其他<br>&#x2F;&#x2F; 集合被修改的次数，使用iterator进行遍历时fail-fast使用<br>private trans<br>&#x2F;&#x2F; Red-black机制常量<br>private static final boolean RED   &#x3D; false;<br>private static final boolean BLACK &#x3D; true;ient int modCount &#x3D; 0;<br>&#x2F;&#x2F; 根节点<br>private transient Entry&lt;K,V&gt; root;<br>&#x2F;&#x2F; 维护顺序使用的比较器<br>private final Comparator&lt;? super K&gt; comparator;</p><p>put方法<br>public V put(K key, V value) {<br>        Entry&lt;K,V&gt; t &#x3D; root;<br>        &#x2F;&#x2F; 如果根节点为空<br>        if (t &#x3D;&#x3D; null) {<br>            &#x2F;&#x2F; 检查插入的key是否为空<br>            compare(key, key); &#x2F;&#x2F; type (and possibly null) check<br>            &#x2F;&#x2F; 当前节点新建<br>            root &#x3D; new Entry&lt;&gt;(key, value, null);<br>            size &#x3D; 1;<br>            modCount++;<br>            return null;<br>        }<br>        int cmp;<br>        Entry&lt;K,V&gt; parent;<br>        &#x2F;&#x2F; split comparator and comparable paths<br>        Comparator&lt;? super K&gt; cpr &#x3D; comparator;<br>        &#x2F;&#x2F; 如果指定了比较器，则使用特定的比较方法<br>        if (cpr !&#x3D; null) {<br>            do {<br>                parent &#x3D; t;<br>                &#x2F;&#x2F; 比较待插入key和当前节点key的大小<br>                cmp &#x3D; cpr.compare(key, t.key);<br>                &#x2F;&#x2F; 如果待插入key小，往左子树遍历<br>                if (cmp &lt; 0)<br>                    t &#x3D; t.left;<br>                &#x2F;&#x2F; 如果待插入key大，往右子树遍历<br>                else if (cmp &gt; 0)<br>                    t &#x3D; t.right;<br>                &#x2F;&#x2F; 如果相等，说明key已存在则更新值<br>                else<br>                    return t.setValue(value);<br>            } while (t !&#x3D; null);<br>        }<br>        &#x2F;&#x2F; 没有指定比较器则使用键范型对应类型的默认比较方法<br>        else {<br>            if (key &#x3D;&#x3D; null)<br>                throw new NullPointerException();<br>            @SuppressWarnings(“unchecked”)<br>                Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key;<br>            do {<br>                parent &#x3D; t;<br>                cmp &#x3D; k.compareTo(t.key);<br>                if (cmp &lt; 0)<br>                    t &#x3D; t.left;<br>                else if (cmp &gt; 0)<br>                    t &#x3D; t.right;<br>                else<br>                    return t.setValue(value);<br>            } while (t !&#x3D; null);<br>        }<br>        &#x2F;&#x2F; 遍历到待插入的位置时，初始化插入节点，进行插入<br>        Entry&lt;K,V&gt; e &#x3D; new Entry&lt;&gt;(key, value, parent);<br>        if (cmp &lt; 0)<br>            parent.left &#x3D; e;<br>        else<br>            parent.right &#x3D; e;<br>        &#x2F;&#x2F; 进入红黑树插入节点后的调整逻辑<br>        fixAfterInsertion(e);<br>        size++;<br>        modCount++;<br>        return null;<br>    }<br>TreeMap的put方法主要逻辑是就是红黑树的插入逻辑，包含两个阶段：<br>1）二叉搜索树的遍历方法，找到一个待插入位置并插入或更新（如果key已存在）；<br>2）插入后执行红黑树对应的调整逻辑；<br>先介绍几个概念：左旋、右旋<br>    &#x2F;** From CLR <em>&#x2F;<br>    &#x2F;&#x2F; 对节点p左旋包括三个操作，本质上也是三个节点的位置互换<br>    &#x2F;&#x2F; 1. p的右子节点变为其右子节点的左子节点<br>    &#x2F;&#x2F; 2. p原右子节点占据p现在的位置<br>    &#x2F;&#x2F; 3. p的位置变为其原右子节点的左子节点<br>    private void rotateLeft(Entry&lt;K,V&gt; p) {<br>        if (p !&#x3D; null) {<br>            Entry&lt;K,V&gt; r &#x3D; p.right;<br>            p.right &#x3D; r.left;<br>            if (r.left !&#x3D; null)<br>                r.left.parent &#x3D; p;<br>            r.parent &#x3D; p.parent;<br>            if (p.parent &#x3D;&#x3D; null)<br>                root &#x3D; r;<br>            else if (p.parent.left &#x3D;&#x3D; p)<br>                p.parent.left &#x3D; r;<br>            else<br>                p.parent.right &#x3D; r;<br>            r.left &#x3D; p;<br>            p.parent &#x3D; r;<br>        }<br>    }<br>右旋为对应的对称操作不再赘述。<br>然后看红黑树具体插入节点后的调整逻辑：<br>    &#x2F;</em>* From CLR *&#x2F;<br>    &#x2F;&#x2F; 红黑树插入节点后的翻转+变色逻辑<br>    private void fixAfterInsertion(Entry&lt;K,V&gt; x) {<br>        &#x2F;&#x2F; 插入节点首先设为红色<br>        x.color &#x3D; RED;<br>        &#x2F;&#x2F; 如果x的父节点为红色则可能需要翻转或变色<br>        while (x !&#x3D; null &amp;&amp; x !&#x3D; root &amp;&amp; x.parent.color &#x3D;&#x3D; RED) {<br>            &#x2F;&#x2F; 如果x的父节点是x祖父节点的左节点<br>            if (parentOf(x) &#x3D;&#x3D; leftOf(parentOf(parentOf(x)))) {<br>                Entry&lt;K,V&gt; y &#x3D; rightOf(parentOf(parentOf(x)));<br>                &#x2F;&#x2F; 如果x的叔节点也为红色，那么换色：x的父节点和叔节点都换为黑色，祖父节点变为红色<br>                if (colorOf(y) &#x3D;&#x3D; RED) {<br>                    setColor(parentOf(x), BLACK);<br>                    setColor(y, BLACK);<br>                    setColor(parentOf(parentOf(x)), RED);<br>                    x &#x3D; parentOf(parentOf(x));<br>                } else {<br>                    &#x2F;&#x2F; 若x叔节点为黑色且x是其父节点的右子节点<br>                    if (x &#x3D;&#x3D; rightOf(parentOf(x))) {<br>                        &#x2F;&#x2F; 那么需要对x的父节点进行左旋<br>                        x &#x3D; parentOf(x);<br>                        rotateLeft(x);<br>                    }<br>                    &#x2F;&#x2F; x父节点变为黑色，x祖父节点变为红色，x祖父节点右旋<br>                    setColor(parentOf(x), BLACK);<br>                    setColor(parentOf(parentOf(x)), RED);<br>                    rotateRight(parentOf(parentOf(x)));<br>                }<br>            } else {<br>                &#x2F;&#x2F; 若x的父节点为其祖父节点的右子节点，此时基本和上述做对称操作<br>                Entry&lt;K,V&gt; y &#x3D; leftOf(parentOf(parentOf(x)));<br>                &#x2F;&#x2F; 若x叔节点为红色，同样对祖父节点、父节点和叔节点换色<br>                if (colorOf(y) &#x3D;&#x3D; RED) {<br>                    setColor(parentOf(x), BLACK);<br>                    setColor(y, BLACK);<br>                    setColor(parentOf(parentOf(x)), RED);<br>                    x &#x3D; parentOf(parentOf(x));<br>                } else {<br>                    &#x2F;&#x2F; 否则若x是其父节点的左子节点，则对齐父节点右旋<br>                    if (x &#x3D;&#x3D; leftOf(parentOf(x))) {<br>                        x &#x3D; parentOf(x);<br>                        rotateRight(x);<br>                    }<br>                    &#x2F;&#x2F; x的父节点变为黑色，祖父节点变为红色，祖父节点左旋<br>                    setColor(parentOf(x), BLACK);<br>                    setColor(parentOf(parentOf(x)), RED);<br>                    rotateLeft(parentOf(parentOf(x)));<br>                }<br>            }<br>        }<br>        root.color &#x3D; BLACK;<br>    }<br>LinkedHashMap</p><p>按照类继承关系，LinkedHashMap继承自HashMap，LinkedHashMap相较于HashMap，除了支持按元素插入顺序遍历外，还支持按元素访问顺序遍历（LRU）。其实现是在HashMap的基础上维护了双向链表的结构来存储节点（感觉和Redis的zset很像，也是维护了dict和skiplist两个数据结构）。具体地，我们需要先了解HashMap的结构和实现；<br>HashMap<br>数据结构<br>HashMap由一个bucket数组组成，每个bucket在两种数据结构之间相互转换：链表和红黑树。链表由Node类实现，红黑树的节点则为TreeNode类。<br>    &#x2F;&#x2F; bucket数组，必要时resize<br>    transient Node&lt;K,V&gt;[] table;</p><pre><code>// 链表节点类，next标记链表的下一个节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;        ...&#125;// 红黑树的节点类，同时标记了前置节点用于删除 */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion    boolean red;    ...&#125;</code></pre><p>LinkedHashMap源码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概览&lt;br&gt;最近优化业务日志规范，我们定义了日志打点的数据结构是形如key-value结构，其中key是日志的业务语意，value为对应的业务值，每处打点我们希望可以实现多个业务语意-值的映射对，并在日志中按照我们在代码中的顺序输出出来。即我们需要一个有序映射的数据结构来做</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shengdoupi.github.io/2023/11/25/hello-world/"/>
    <id>http://shengdoupi.github.io/2023/11/25/hello-world/</id>
    <published>2023-11-25T11:02:04.136Z</published>
    <updated>2023-11-25T11:02:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
