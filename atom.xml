<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shengdoupi&#39;s</title>
  
  <subtitle>posts</subtitle>
  <link href="http://shengdoupi.github.io/atom.xml" rel="self"/>
  
  <link href="http://shengdoupi.github.io/"/>
  <updated>2024-01-04T04:59:59.618Z</updated>
  <id>http://shengdoupi.github.io/</id>
  
  <author>
    <name>shengdoupi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-IoC原理</title>
    <link href="http://shengdoupi.github.io/2024/01/04/spring-ioc/"/>
    <id>http://shengdoupi.github.io/2024/01/04/spring-ioc/</id>
    <published>2024-01-04T04:59:42.408Z</published>
    <updated>2024-01-04T04:59:59.618Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker-镜像构建</title>
    <link href="http://shengdoupi.github.io/2024/01/04/docker-build/"/>
    <id>http://shengdoupi.github.io/2024/01/04/docker-build/</id>
    <published>2024-01-04T04:55:56.381Z</published>
    <updated>2024-01-04T04:59:27.637Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://shengdoupi.github.io/2024/01/04/mysql-uniquekey/"/>
    <id>http://shengdoupi.github.io/2024/01/04/mysql-uniquekey/</id>
    <published>2024-01-04T04:55:25.325Z</published>
    <updated>2024-01-04T04:55:25.325Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring-AOP原理</title>
    <link href="http://shengdoupi.github.io/2024/01/04/spring-aop/"/>
    <id>http://shengdoupi.github.io/2024/01/04/spring-aop/</id>
    <published>2024-01-04T04:55:13.334Z</published>
    <updated>2024-01-04T04:58:37.968Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL优化-orderBy</title>
    <link href="http://shengdoupi.github.io/2024/01/04/mysql-order-by/"/>
    <id>http://shengdoupi.github.io/2024/01/04/mysql-order-by/</id>
    <published>2024-01-04T04:54:27.323Z</published>
    <updated>2024-01-04T04:58:22.731Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://shengdoupi.github.io/2023/12/10/1/"/>
    <id>http://shengdoupi.github.io/2023/12/10/1/</id>
    <published>2023-12-10T13:32:59.657Z</published>
    <updated>2023-12-10T13:32:59.657Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java有序集合</title>
    <link href="http://shengdoupi.github.io/2023/11/25/java_ordered_collection/"/>
    <id>http://shengdoupi.github.io/2023/11/25/java_ordered_collection/</id>
    <published>2023-11-25T11:04:11.946Z</published>
    <updated>2024-01-08T16:23:17.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a><strong>概览</strong></h1><p>最近优化业务日志规范，我们定义了日志打点的数据结构是形如key-value结构，其中key是日志的业务语意，value为对应的业务值，每处打点我们希望可以实现多个业务语意-值的映射对，并在日志中按照我们在代码中的顺序输出出来。即我们需要一个有序映射的数据结构来做存储，选择使用LinkedHashMap。</p><p>Java集合中有些接口或实现类是约束、实现了元素有序能力的，这里分两类：</p><ol><li>键自然序或者指定比较顺序进行键值排序的能力，比如SortedMap（对应的SortedSet），其实现类TreeMap；</li><li>按元素的插入先后顺序进行排序，比如接口List、Queue，以及Map的实现类LinkedHashMap这些；</li></ol><p>这篇文章专门介绍Java中有序集合的实现，特别地从源码介绍TreeMap和LinkedHashmap。</p><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h1><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/r4mlQgzom8mBqxow/img/0ceb0cb8-4d62-4be8-b407-ff842fef6cef.tif" alt="img"></p><p>按照类继承关系，下面先介绍Map、SortedMap和NavigableMap的接口规范和方法约束，然后详细介绍TreeMap的方法实现。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map是一个将键映射到值的对象。映射不能包含重复的键；每个键最多可以映射到一个值。</span><br><span class="line">Map接口提供了三个集合视图，允许将Map的内容视为一组键、一组值或一组键值映射。Map的顺序定义为其集合视图上的迭代器返回其元素的顺序。一些Map实现，如TreeMap类，对它们的顺序做出了特定的保证；其他类（如HashMap类）则不然。</span><br></pre></td></tr></table></figure><p>上述截取自JDK官方对Map接口的注解翻译，Map主要是用来存放不重复的键以及其键-值唯一映射。Map接口规范没有约束按特定顺序存放元素和按序读取元素的能力。</p><h2 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a><strong>SortedMap</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap是一个进一步提供其键的总排序的Map。SortedMap是根据其键的自然顺序进行排序的，或者由通常在SortedMap创建时提供的比较器进行排序。当迭代SortedMap的集合视图（由entrySet、keySet和values方法返回）时，会反映出这种顺序。提供了几个额外的操作以利用有序能力。</span><br></pre></td></tr></table></figure><p>上述截取自SortedMap的官方注释，SortedMap提供了键的排序能力，以及一些方法来使用这个能力。下面先介绍接口规范再介绍提供的方法。</p><h3 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a><strong>接口规范</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 插入排序映射的所有键都必须实现Comparable接口（或被指定的comparator接受）。此外，所有这些键必须是相互可比较的：k1.compareTo（k2）（或comparator.compare（k1，k2））。</span><br></pre></td></tr></table></figure><p>第一点是SortedMap有序能力本质上需要依赖compareTo方法或者compare方法，因此键的类型必须实现Comparable接口或者被某个comparator接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 如果SortedMap要正确实现map接口，则SortedMap（无论是否提供显式比较器）维护的顺序必须与equals一致。这是因为Map接口是根据equals操作定义的，但SortedMap使用compareTo（或compare）方法执行键之间的比较，因此从SortedMap的角度来看，compareTo认为相等的两个键需要是equal的。（TreeMap行为是明确定义的，即使它的排序与等于不一致；它只是没有遵守Map接口的一般约定。）</span><br></pre></td></tr></table></figure><p>第二点是说SortedMap比较键值时使用的compareTo或compare方法需要与equals结果一致；这点Comparator接口里有更具体的规范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(compare(x, y)==0) == (x.equals(y))</span><br></pre></td></tr></table></figure><p>这处约束主要是Map接口约束使用equals方法来判定键是否相同，SortedMap接口约束使用compare方法来比较两个键的顺序，而SortedMap是Map接口的扩展接口，因此需要遵循Map接口的约束，也即判断键是否相同这点两处需要保持一致；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3. 所有通用SortedMap实现类都应该提供四个“标准”构造函数。虽然接口不能指定必需的构造函数，但不可能强制执行此建议。所有SortedMap现的预期“标准”构造函数是：</span><br><span class="line">1)一个void（无参数）构造函数，它创建一个根据键的自然顺序排序的空SortedMap。</span><br><span class="line">2)具有Comparator类型的单个参数的构造函数，它创建一个根据指定的比较器排序的空SortedMap。</span><br><span class="line">3)具有Map类型的单个参数的构造函数，它创建一个新的映射，该映射具有与其参数相同的键值映射，并根据键的自然顺序进行排序。</span><br><span class="line">4)具有SortedMap类型的单个参数的构造函数，它创建一个新的SortedMap，其具有与输入SortedMap相同的键值映射和顺序。</span><br></pre></td></tr></table></figure><p>第三点约束是SortedMap接口对构造函数的要求，总结就是当参数里不指定特定的比较方法时，构造的对象需提供自然顺序排序的能力。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>SortedMap提供了一些方法利用到排序能力：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 指定键起止范围的子映射</span><br><span class="line">SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);</span><br><span class="line">// 从第一个键到指定键的子映射</span><br><span class="line">SortedMap&lt;K,V&gt; headMap(K toKey);</span><br><span class="line">// 从指定键到最后一个键的子映射</span><br><span class="line">SortedMap&lt;K,V&gt; tailMap(K fromKey);</span><br><span class="line">// 返回当前第一个键</span><br><span class="line">K firstKey();</span><br><span class="line">// 返回当前最后一个键</span><br><span class="line">K lastKey();</span><br></pre></td></tr></table></figure><h2 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a><strong>NavigableMap</strong></h2><p>SortedMap提供的方法中对有序的利用能力局限在获取已知键大小范围对应的映射，而很多时候我们并不知道需要获取的键的具体大小， 只知道一个方向：比如我们想获得比指定key大的下一个元素；这时只用SortedMap定义的方法我们只能获取到最大的key，然后再使用subMap获取指定key和最大key之间的子映射，再遍历获得比指定key大的下一个元素。</p><p>NavigableMap是SortedMap的扩展接口，顾名思义提供了导航的能力，提供了获取指定方向的键值对的方法，返回给定搜索目标的最接近匹配项。</p><h3 id="接口规范-1"><a href="#接口规范-1" class="headerlink" title="接口规范"></a><strong>接口规范</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用导航方法扩展的SortedMap，返回给定搜索目标的最接近匹配项。方法lowerEntry、floorEntry、ceilingEntry和higherEntry返回Map。分别与小于、小于或等于、大于或等于和大于给定键的键关联的条目对象，如果没有这样的键，则返回null。类似地，lowerKey、floorKey、ceilingKey和higherKey方法只返回关联的键。所有这些方法都是为定位而设计的，而不是遍历条目。</span><br></pre></td></tr></table></figure><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>NavigableMap新增的方法除了接口规范中已提及的还有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 返回对应的逆序集合</span><br><span class="line">NavigableMap&lt;K,V&gt; descendingMap();</span><br><span class="line">// 移除此时第一个元素并返回</span><br><span class="line">Map.Entry&lt;K,V&gt; pollFirstEntry();</span><br><span class="line">// 移除此时最后一个元素并返回</span><br><span class="line">Map.Entry&lt;K,V&gt; pollLastEntry();</span><br></pre></td></tr></table></figure><h2 id="TreeMap源码"><a href="#TreeMap源码" class="headerlink" title="TreeMap源码"></a><strong>TreeMap源码</strong></h2><p>TreeMap的有序能力基于红黑树（<a href="https://oi-wiki.org/ds/rbtree/%EF%BC%89%E5%AE%9E%E7%8E%B0%E3%80%82%E5%9B%A0%E6%AD%A4TreeMap%E7%9A%84%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(log(n)">https://oi-wiki.org/ds/rbtree/）实现。因此TreeMap的元素插入、查找和删除的时间复杂度为O(log(n)</a>), 其中n为元素的个数。使用红黑树是因为相较于平衡树，红黑树不会因为插入和删除时追求绝对的平衡而过多的调整，最坏情况下也能保证在O（log n）的时间复杂度查找到某个节点。所以对于搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。【1】</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h3><h4 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a><strong>Entry类</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    boolean color = BLACK;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Make a new cell with given key, value, and parent, and with</span><br><span class="line">     * &#123;@code null&#125; child links, and BLACK color.</span><br><span class="line">     */</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap的Entry类作为元素类，除了基本的key、value之外，自身还作为一个节点包括了红黑树的节点信息：父节点、左右子节点和颜色布尔值。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 集合被修改的次数，使用iterator进行遍历时fail-fast使用</span><br><span class="line">private trans   </span><br><span class="line">// Red-black机制常量</span><br><span class="line">private static final boolean RED   = false;</span><br><span class="line">private static final boolean BLACK = true;ient int modCount = 0;</span><br><span class="line">// 根节点</span><br><span class="line">private transient Entry&lt;K,V&gt; root;</span><br><span class="line">// 维护顺序使用的比较器</span><br><span class="line">private final Comparator&lt;? super K&gt; comparator;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        // 如果根节点为空</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            // 检查插入的key是否为空</span><br><span class="line">            compare(key, key); // type (and possibly null) check</span><br><span class="line">            // 当前节点新建</span><br><span class="line">            root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">            size = 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        // split comparator and comparable paths</span><br><span class="line">        Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">        // 如果指定了比较器，则使用特定的比较方法</span><br><span class="line">        if (cpr != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                // 比较待插入key和当前节点key的大小</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                // 如果待插入key小，往左子树遍历</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                // 如果待插入key大，往右子树遍历</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                // 如果相等，说明key已存在则更新值</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        // 没有指定比较器则使用键范型对应类型的默认比较方法</span><br><span class="line">        else &#123;</span><br><span class="line">            if (key == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历到待插入的位置时，初始化插入节点，进行插入</span><br><span class="line">        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        else</span><br><span class="line">            parent.right = e;</span><br><span class="line">        // 进入红黑树插入节点后的调整逻辑</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeMap的put方法主要逻辑是就是红黑树的插入逻辑，包含两个阶段：</p><p>1）二叉搜索树的遍历方法，找到一个待插入位置并插入或更新（如果key已存在）；</p><p>2）插入后执行红黑树对应的调整逻辑；</p><p>先介绍几个概念：左旋、右旋</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** From CLR */</span><br><span class="line">// 对节点p左旋包括三个操作，本质上也是三个节点的位置互换</span><br><span class="line">// 1. p的右子节点变为其右子节点的左子节点</span><br><span class="line">// 2. p原右子节点占据p现在的位置</span><br><span class="line">// 3. p的位置变为其原右子节点的左子节点</span><br><span class="line">private void rotateLeft(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    if (p != null) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        if (r.left != null)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        if (p.parent == null)</span><br><span class="line">            root = r;</span><br><span class="line">        else if (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        else</span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右旋为对应的对称操作不再赘述。</p><p>然后看红黑树具体插入节点后的调整逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/** From CLR */</span><br><span class="line">// 红黑树插入节点后的翻转+变色逻辑</span><br><span class="line">private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">    // 插入节点首先设为红色</span><br><span class="line">    x.color = RED;</span><br><span class="line">    // 如果x的父节点为红色则可能需要翻转或变色</span><br><span class="line">    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        // 如果x的父节点是x祖父节点的左节点</span><br><span class="line">        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            // 如果x的叔节点也为红色，那么换色：x的父节点和叔节点都换为黑色，祖父节点变为红色</span><br><span class="line">            if (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 若x叔节点为黑色且x是其父节点的右子节点</span><br><span class="line">                if (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    // 那么需要对x的父节点进行左旋</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                // x父节点变为黑色，x祖父节点变为红色，x祖父节点右旋</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 若x的父节点为其祖父节点的右子节点，此时基本和上述做对称操作</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            // 若x叔节点为红色，同样对祖父节点、父节点和叔节点换色</span><br><span class="line">            if (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 否则若x是其父节点的左子节点，则对齐父节点右旋</span><br><span class="line">                if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                // x的父节点变为黑色，祖父节点变为红色，祖父节点左旋</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h1><p><img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/r4mlQgzom8mBqxow/img/6912f8b5-6382-4ca9-937d-53642f15cc0b.tif" alt="img"></p><p>按照类继承关系，LinkedHashMap继承自HashMap，LinkedHashMap相较于HashMap，除了支持按元素插入顺序遍历外，还支持按元素访问顺序遍历（LRU）。实现方法是在HashMap的基础上维护了双向链表的结构来存储节点（感觉和Redis的zset很像，也是维护了dict和skiplist两个数据结构）。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><p>HashMap由一个bucket数组组成，由于每个bucket在两种数据结构之间相互转换：链表和红黑树。链表由Node类实现，红黑树的节点则为TreeNode类。为了支持节点变为TreeNode后仍然能满足LinkedHashMap维护节点顺序的要求，TreeNode类也维护了两个前后节点的属性。具体的实现是通过在LinkedHashMap里定义一个维护了前后节点的类Entry，再让HashMap的TreeNode继承LinkedHashMap.Entry。【2】这篇文章里详细介绍了为何这样设计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// bucket数组，必要时resize</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 链表节点类，next标记链表的下一个节点</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 红黑树的节点类，同时标记了前置节点用于删除</span><br><span class="line"> */</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// LinkedHashMap.Entry里增加了前后节点属性</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，提供了布尔值来辅助按照访问顺序排序的能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 是否按访问顺讯排序</span><br><span class="line">   final boolean accessOrder;</span><br></pre></td></tr></table></figure><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a><strong>方法</strong></h2><p>LinkedHashhmap关于元素的插入和删除方法都是在HashMap的基础上实现了定制的调整方法，访问方法则是完全重写。</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a><strong>get</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 重写了get方法</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">          return null;</span><br><span class="line">      // 如果开启了按访问顺序排序，则调用afterNodeAccess访问后置方法</span><br><span class="line">      if (accessOrder)</span><br><span class="line">          afterNodeAccess(e);</span><br><span class="line">      return e.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>get方法重写后多了一个访问后置调整逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    // 当前最新访问的节点并不是本次访问的节点，则进入调整逻辑</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        // 调整总体记录：把当前节点放到尾节点作为最新访问的节点</span><br><span class="line">        // 当前节点的后置节点置空</span><br><span class="line">        p.after = null;</span><br><span class="line">        // 如果当前节点的原前置节点为空，则当前的节点的原后置节点变为首节点</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">           // 否则原前置节点的后置节点变为原后置节点，相当于在原位置删除当前节点</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        // 把p放到末尾，如果当前尾节点为空，那么p既是头节点也是尾节点</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该访问后置逻辑中，做了把当前访问的节点放到尾节点作为最新访问节点的操作。</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>put方法复用了HashMap的put方法，主要是调用putVal这个final方法，不一样的是LinkedHashMap重写了内部的afterNodeAccess和afterNodeInsertion 这两个后置方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 参数中的hash为key的hash方法值 </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 当前数组为空则resize</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 如果数组在当前hash取模位置为空，则新建一个节点放到数组中</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 如果key和取模位置的头节点的key相等，那么会做节点值更新操作</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 如果该处已是红黑树，那么直接调用红黑树插入方法</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 否则说明是链表结构，进行插入操作</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 遍历到链表的最后节点</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 达到条件则将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 遍历到已存在的key则跳出遍历进行值更新操作</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // key已存在，进行值更新操作</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 调用访问后置方法，将当前key放到双链表的尾节点作为最新访问节点</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 调用插入后置方法，LinkeHashMap已重写</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> LinkeHashMap重写了调用插入后置方法，通过插入后的双向链表调整来维护顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 参数evict标记当前数组是否处于create模式，true代表不处于</span><br><span class="line">// 插入了一个新元素，判断是否需要移除最久未访问的节点，如果需要则删除该节点</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    // removeEldestEntry默认为false，需要自己定义达到移除最老元素的条件并重写该方法</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内removeEldestEntry默认为false，需要自己定义达到移除最老元素的条件并重写该方法，比如可以自定义LRU的条件。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h1><p>【1】<a href="https://zhuanlan.zhihu.com/p/621122622">https://zhuanlan.zhihu.com/p/621122622</a></p><p>【2】<a href="https://blog.csdn.net/shark_chili3007/article/details/107249595">https://blog.csdn.net/shark_chili3007/article/details/107249595</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;&lt;strong&gt;概览&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;最近优化业务日志规范，我们定义了日志打点的数据结构是形如key-value结构，其中key是日志的业务语意</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shengdoupi.github.io/2023/11/25/hello-world/"/>
    <id>http://shengdoupi.github.io/2023/11/25/hello-world/</id>
    <published>2023-11-25T11:02:04.136Z</published>
    <updated>2023-11-25T11:02:04.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
